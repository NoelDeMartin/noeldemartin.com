---
id: implementing-a-recipes-manager-using-solid-16
blueprint: comment
title: 'Implementing a Recipes Manager using Solid - 16'
task: 'entry::implementing-a-recipes-manager-using-solid'
publication_date: '2022-05-08 17:05:25'
---

Today I'm happy to report that I'm done with features for v0.1! ðŸ¥³

As always, I ended up going a _bit_ overboard and actually implemented more than I intended... But I'm very confident that in the next update, the app will be ready for production. Not released, but good enough to start using it myself.

If you look at the list of things left that I wrote a couple of updates ago, the first one says "Recipes sharing". This is something that I think will be very important, because it'll make this app useful for non-Solid users as well. However, this has been my first time implementing anything related with authorization, so I had to learn a bit about it.

This could get very long, so I'll summarize saying that there are currently two systems for handling authorization in Solid: [WAC](https://solidproject.org/TR/wac) and [ACP](https://solid.github.io/authorization-panel/acp-specification/). WAC was the first one, and in practice is supported by most servers (as far as I know, [ESS](https://inrupt.com/products/enterprise-solid-server/) is the only one that doesn't). ACP is the new approach, but it doesn't seem to be supported by most servers and to be honest, seems a lot more complicated (I could understand WAC pretty quickly, but reading the ACP spec went a bit over my head). So in the end, I decided to just support WAC for now.

There are multiple reasons for making this decision. First, as you may know if you're reading this, the development of this app is taking ages and I want to be done with it ([scope hammer](https://basecamp.com/shapeup/3.5-chapter-14#scope-hammering)!). Second, the lack of support doesn't make it appealing (to be honest, this reminds me a lot to [the interoperability spec](https://solid.github.io/data-interoperability-panel/specification/); it sounds cool in theory, but it's still too experimental to be used in practice). And third, I don't think this is a must-have in my app. After all, users should be able to update the permissions of their files using a different app, that's the point of Solid. I could also start using [Inrupt's client library](https://github.com/inrupt/solid-client-js), which supports both; but I don't think this use-case is strong enough to warrant adding more dependencies (and I want to keep them [down to a minimum](https://bundlephobia.com/package/@inrupt/solid-client@1.22.0)). This is also the first and only feature that doesn't really work offline, but given the nature of the use-case, I'd say that's ok.

So with that, recipes sharing is done!

Something else I've been working on these last couple of weeks was the "Smooth onboarding experience". When I wrote that, I thought this meant doing some UX/UI and copy writing. But the more I looked into it, the more I realized that something was missing. I said before that importing recipes from the Web will be the main mechanism for users to populate their cookbook. But there was still an elephant in the room called CORS. My previous solution was to instruct people into copy pasting the source of a website. But as you can imagine, that wasn't very user-friendly. So I bit the bullet, and I've ended up implementing [a proxy server](https://github.com/NoelDeMartin/proxy) that will take care of this. There are still a couple of things left, though. The first one is that I still need to work on communicating this to users. I could just do it without even telling them, but it goes against my ethos for the app (100% client side, decentralized, etc.). And I also want to give them an opportunity to use their own proxy. The other thing I want to look into is to actually implement a proxy properly ðŸ˜…. What I've done thus far is too specific to my app (albeit very simple, I just have a `/fetch` endpoint on a server that replies to `POST` requests). Because of that, the only real option for someone who wants to use their own proxy is to self-host my own solution, which is Open Source. But it seems like [HTTP proxies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling#http_tunneling) are a thing, and they follow a standard. So I should be able to implement that and any existing proxy service should work. I'll probably look into that after I start using the app myself (but before the release).

If you look at the list of things left, you'll notice there's still a bunch left. But I've decided to drop a couple. I won't be doing the "Vue ecosystem review" nor the "http vs https schema.org handling" yet. So that only leaves some general housekeeping tasks, and then you'll finally be able to experience the app for yourself.
